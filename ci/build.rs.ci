use std::env;
use std::path::{Path, PathBuf};

fn main() {
    println!("cargo:rustc-check-cfg=cfg(python_embedded)");
    println!("cargo:rerun-if-env-changed=PYTHON_EMBED_HOME");
    println!("cargo:rerun-if-env-changed=PYO3_LIB_DIR");
    println!("cargo:rerun-if-env-changed=PYO3_INCLUDE_DIR");

    let manifest_dir =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set"));

    let default_python_home = ["python-standalone", "python-musl", "python-gnu"]
        .iter()
        .map(|folder| {
            manifest_dir
                .join("third_party")
                .join(folder)
                .join("python")
                .join("install")
        })
        .find(|path| path.exists())
        .unwrap_or_else(|| {
            manifest_dir
                .join("third_party")
                .join("python-gnu")
                .join("python")
                .join("install")
        });

    let python_home = env::var("PYTHON_EMBED_HOME")
        .map(PathBuf::from)
        .unwrap_or(default_python_home);

    let lib_dir = env::var("PYO3_LIB_DIR")
        .map(PathBuf::from)
        .unwrap_or_else(|_| python_home.join("lib"));
    let include_dir = env::var("PYO3_INCLUDE_DIR")
        .map(PathBuf::from)
        .unwrap_or_else(|_| python_home.join("include"));

    let target_triple = env::var("TARGET").unwrap_or_else(|_| String::from("x86_64-unknown-linux-gnu"));
    let config_suffix = target_triple.replace("unknown-", "");
    let config_dir_candidates = [
        lib_dir
            .join("python3.13")
            .join(format!("config-3.13-{config_suffix}")),
        lib_dir
            .join("python3.13")
            .join("config-3.13-x86_64-linux-gnu"),
    ];
    let config_dir = config_dir_candidates
        .into_iter()
        .find(|path| path.exists())
        .unwrap_or_else(|| {
            lib_dir
                .join("python3.13")
                .join(format!("config-3.13-{config_suffix}"))
        });

    for dir in [&lib_dir, &config_dir, &include_dir] {
        if dir.exists() {
            println!("cargo:rerun-if-changed={}", dir.display());
        }
    }

    add_link_search(&lib_dir);
    add_link_search(&config_dir);

    let build_lib_dir = python_home
        .parent()
        .map(|p| p.join("build").join("lib"))
        .unwrap_or_else(|| {
            ["python-standalone", "python-musl", "python-gnu"]
                .iter()
                .map(|folder| {
                    manifest_dir
                        .join("third_party")
                        .join(folder)
                        .join("python")
                        .join("build")
                        .join("lib")
                })
                .find(|path| path.exists())
                .unwrap_or_else(|| {
                    manifest_dir
                        .join("third_party")
                        .join("python-gnu")
                        .join("python")
                        .join("build")
                        .join("lib")
                })
        });
    add_link_search(&build_lib_dir);

    let search_dirs: Vec<&Path> = [&lib_dir, &config_dir, &build_lib_dir]
        .into_iter()
        .map(|p| p.as_path())
        .collect();

    let static_candidates = search_dirs
        .iter()
        .map(|dir| dir.join("libpython3.13.a"))
        .collect::<Vec<_>>();

    if static_candidates.iter().any(|p| p.exists()) {
        println!("cargo:rustc-cfg=python_embedded");
        let mut static_lib_paths = Vec::new();

        // Ensure the final binary is linked fully static once we have the static Python runtime.
        println!("cargo:rustc-link-arg=-static");

        if let Some(path) = find_static_lib("python3.13", &search_dirs) {
            static_lib_paths.push(path);
        } else {
            println!(
                "cargo:warning=libpython3.13.a not found under {}; static linking will fail",
                python_home.display()
            );
        }

        // Source-built Python doesn't bundle extra libraries separately
        // Just link libpython statically
        if !static_lib_paths.is_empty() {
            for path in static_lib_paths {
                println!("cargo:rustc-link-arg={}", path.display());
            }
        }

        for lib in ["pthread", "dl", "util", "m", "z"] {
            println!("cargo:rustc-link-lib={lib}");
        }
        println!("cargo:rustc-link-arg=-Wl,--export-dynamic");
    } else {
        println!(
            "cargo:warning=libpython3.13.a not found under {}",
            python_home.display()
        );
    }
}

fn add_link_search(path: &Path) {
    if path.exists() {
        println!("cargo:rustc-link-search=native={}", path.display());
    }
}

fn find_static_lib<'a>(name: &str, search_dirs: &'a [&Path]) -> Option<PathBuf> {
    search_dirs
        .iter()
        .map(|dir| dir.join(format!("lib{name}.a")))
        .find(|path| path.exists())
}

